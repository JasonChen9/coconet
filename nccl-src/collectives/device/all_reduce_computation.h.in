/*************************************************************************
 * Copyright (c) 2015-2019, NVIDIA CORPORATION. All rights reserved.
 *
 * See LICENSE.txt for license information
 ************************************************************************/

#include "devcomm.h"
#include "primitives_computation.h"
#include "collectives.h"
#include <cooperative_groups.h>

template<int UNROLL, class FUNC, typename T>
__device__ void ncclAllReduceComputationRingKernel(struct CollectiveArgs* args) {
  const int tid = threadIdx.x;
  const int nthreads = args->nThreads-WARP_SIZE;
  const int bid = args->bid;
  struct ncclDevComm* comm = args->comm;
  struct ncclChannel* channel = comm->channels+blockIdx.x;
  struct ncclRing* ring = &channel->ring;
  const ssize_t size = args->N;
  const int nranks = comm->nRanks;
  const int stepSize = channel->buffSize / (sizeof(T)*NCCL_STEPS);
  const int chunkSize = stepSize * ALLREDUCE_CHUNKSTEPS;
  const ssize_t loopSize = args->nChannels*(ssize_t)chunkSize;

  // Compute pointers
  // const T * __restrict__ thisInput = (const T*)args->ThisInput;
  // T * __restrict__ thisOutput = (T*)args->ThisOutput;
  /*RingSimple: {INSERT ARGS}*/
  /*RingSimple: {INSERT SHARED MEMORY FOR REDUCTION}*/

  ncclPrimitivesComputation<UNROLL, ALLREDUCE_CHUNKSTEPS/ALLREDUCE_SLICESTEPS, ALLREDUCE_SLICESTEPS, T, 1, 1, FUNC>
    prims(tid, args->nThreads, &ring->prev, &ring->next, /*{RingSimple: {INSERT OUTPUT}}*/, stepSize, channel, comm, args->opCount);

  for (ssize_t gridOffset = 0; gridOffset < size; gridOffset += nranks*loopSize) {
    int realChunkSize = min(chunkSize, DIVUP(size-gridOffset,nranks*args->nChannels));
    ALIGN_SIZE(realChunkSize, nthreads*sizeof(uint64_t)/sizeof(T));
    ssize_t chunkOffset = gridOffset + bid*nranks*realChunkSize;

    /////////////// begin AllReduce steps ///////////////
    ssize_t offset;
    int nelem;
    int chunk;

    // step 0: push data to next GPU
    chunk = ring->devUserRanks[nranks-1];
    offset = chunkOffset + chunk * realChunkSize;
    nelem = min(realChunkSize, size-offset);
    /*RingSimple: {INSERT SEND}*/
    //prims.send(thisInput+offset, nelem);

    // k-2 steps: reduce and copy to next GPU
    for (int j=2; j<nranks; ++j) {
      chunk = ring->devUserRanks[nranks-j];
      offset = chunkOffset + chunk * realChunkSize;
      nelem = min(realChunkSize, size-offset);
      /*RingSimple: {INSERT RECV_REDUCE_SEND}*/
      //prims.recvReduceSend(thisInput+offset, nelem);
    }

    // step k-1: reduce this buffer and data, which will produce the final
    // result that we store in this data and push to the next GPU
    chunk = ring->devUserRanks[0];
    offset = chunkOffset + chunk * realChunkSize;
    nelem = min(realChunkSize, size-offset);
    
    /*RingSimple: {INSERT DIRECT_RECV_REDUCE_COPY_SEND}*/
    //prims.directRecvReduceCopySend(thisInput+offset, thisOutput+offset, offset, nelem);
/*RingSimple: REDUCTION {END FOR LOOP FOR}*/
    
/*RingSimple: REDUCTION {PER-GPU REDUCTION}*/

/*RingSimple: REDUCTION {TRANSFER}*/
    
  /*RingSimple: REDUCTION {BEGIN FOR LOOP FOR}*/
  /*RingSimple: REDUCTION {COMPUTATION}*/

    // k-2 steps: copy to next GPU
    for (int j=1; j<nranks-1; ++j) {
      chunk = ring->devUserRanks[nranks-j];
      offset = chunkOffset + chunk * realChunkSize;
      nelem = min(realChunkSize, size-offset);
      /*RingSimple: {INSERT DIRECT_RECV_COPY_SEND}*/
      //prims.directRecvCopySend(thisOutput+offset, offset, nelem);
    }

    // Make final copy from buffer to dest.
    chunk = ring->devUserRanks[1];
    offset = chunkOffset + chunk * realChunkSize;
    nelem = min(realChunkSize, size-offset);

    // Final wait/copy.
    /*RingSimple: {INSERT DIRECT_RECV}*/
    //prims.directRecv(thisOutput+offset, offset, nelem);
  }
}

template<int UNROLL, class FUNC, typename T>
__device__ void ncclAllReduceComputationTreeKernel(struct CollectiveArgs* args) {
  const int tid = threadIdx.x;
  const int nthreads = args->nThreads-WARP_SIZE;
  const int bid = args->bid;
  struct ncclDevComm* comm = args->comm;
  struct ncclChannel* channel = comm->channels+blockIdx.x;
  const ssize_t size = args->N;
  const int stepSize = channel->buffSize / (sizeof(T)*NCCL_STEPS);
  int chunkSize = args->lastChunkSize;
  const ssize_t minChunkSize = nthreads*8*sizeof(uint64_t) / sizeof(T);
  const ssize_t loopSize = args->nChannels*chunkSize;

  if (loopSize > size) {
    chunkSize = DIVUP(size, args->nChannels*minChunkSize)*minChunkSize;
  }

  // Compute pointers
  // const T * __restrict__ thisInput = (const T*)args->ThisInput;
  // T * __restrict__ thisOutput = (T*)args->ThisOutput;
  /*TREESimple: {INSERT ARGS}*/

  do {
    struct ncclTree* tree = &channel->treeUp;
    // Reduce : max number of recv is 3, max number of send is 1 (binary tree + local)
    ncclPrimitivesComputation<UNROLL/2, 1, 1, T, NCCL_MAX_TREE_ARITY, 1, FUNC> prims(tid, args->nThreads, tree->down, &tree->up, NULL, stepSize, channel, comm, args->opCount);
    for (ssize_t gridOffset = 0; gridOffset < size; gridOffset += loopSize) {
      // Up
      ssize_t offset = gridOffset + bid*chunkSize;
      int nelem = min(chunkSize, size-offset);
      if (tree->up == -1) {
        /*TREESimple: {INSERT RECV_REDUCE_COPY}*/
        // prims.recvReduceCopy(thisInput+offset, thisOutput+offset, nelem);
      } else if (tree->down[0] == -1) {
        /*TREESimple: {INSERT SEND}*/
        // prims.send(thisInput+offset, nelem);
      } else {
        /*TREESimple: {INSERT RECV_REDUCE_SEND}*/
        // prims.recvReduceSend(thisInput+offset, nelem);
      }
    }
  } while(0);

  do {
    struct ncclTree* tree = &channel->treeDn;
    // Broadcast : max number of recv is 1, max number of send is 3 (binary tree + local)
    ncclPrimitivesComputation<UNROLL/2, 1, 1, T, 1, NCCL_MAX_TREE_ARITY, FUNC> prims(tid, args->nThreads, &tree->up, tree->down, NULL, stepSize/*{TREESimple: {stepSize MIXED PRECISION FACTOR}*/, channel, comm, args->opCount);
    for (ssize_t gridOffset = 0; gridOffset < size; gridOffset += loopSize) {
      // Down
      ssize_t offset = gridOffset + bid*chunkSize;
      int nelem = min(chunkSize, size-offset);
      if (tree->up == -1) {
        /*TREESimple: {INSERT SEND OUTPUT}*/
        // prims.send(thisOutput+offset, nelem);
      } else if (tree->down[0] == -1) {
        /*TREESimple: {INSERT RECV OUTPUT}*/
        // prims.recv(thisOutput+offset, nelem);
      } else {
        /*TREESimple: {INSERT RECV_COPY_SEND}*/
        // prims.recvCopySend(thisOutput+offset, nelem);
      }
    }
  } while(0);
}

template<int UNROLL, class FUNC, typename T>
__device__ void ncclAllReduceComputationCollNetKernel(struct CollectiveArgs* args) {
  // const int tid = threadIdx.x;
  // const int nthreads = args->nThreads-WARP_SIZE;
  // const int bid = args->bid;
  // struct ncclDevComm* comm = args->comm;
  // struct ncclChannel* channel = comm->channels+blockIdx.x;
  // const ssize_t size = args->N;
  // const int stepSize = channel->buffSize / (sizeof(T)*NCCL_STEPS);
  // int chunkSize = args->lastChunkSize;
  // const ssize_t minChunkSize = nthreads*8*sizeof(uint64_t) / sizeof(T);
  // const ssize_t loopSize = args->nChannels*chunkSize;

  // if (loopSize > size) {
  //   chunkSize = DIVUP(size, args->nChannels*minChunkSize)*minChunkSize;
  // }

  // // Compute pointers
  // const T * __restrict__ thisInput = (const T*)args->ThisInput;
  // T * __restrict__ thisOutput = (T*)args->ThisOutput;
  assert(false);
  // if (blockIdx.x < args->nChannels) { // first half of the channels do reduce
  //   struct ncclTree* tree = &channel->collTreeUp;
  //   ncclPrimitivesComputation<UNROLL, 1, 1, T, 1, 1, FUNC> prims(tid, args->nThreads, tree->down, &tree->up, NULL, stepSize, channel, comm, args->opCount);
  //   for (ssize_t gridOffset = 0; gridOffset < size; gridOffset += loopSize) {
  //     // Up
  //     ssize_t offset = gridOffset + bid*chunkSize;
  //     int nelem = min(chunkSize, size-offset);
  //     if (tree->up == -1) {
  //       prims.recvReduceCopy(thisInput+offset, thisOutput+offset, nelem);
  //     } else if (tree->down[0] == -1) {
  //       prims.send(thisInput+offset, nelem);
  //     } else {
  //       prims.recvReduceSend(thisInput+offset, nelem);
  //     }
  //   }
  // }

  // if (blockIdx.x >= args->nChannels) { // second half of the channels do broadcast
  //   struct ncclTree* tree = &channel->collTreeDn;
  //   ncclPrimitivesComputation<UNROLL, 1, 1, T, 1, 1, FUNC> prims(tid, args->nThreads, &tree->up, tree->down, NULL, stepSize, channel, comm, args->opCount);
  //   for (ssize_t gridOffset = 0; gridOffset < size; gridOffset += loopSize) {
  //     // Down
  //     ssize_t offset = gridOffset + bid*chunkSize;
  //     int nelem = min(chunkSize, size-offset);
  //     if (tree->up == -1) {
  //       prims.send(thisOutput+offset, nelem);
  //     } else if (tree->down[0] == -1) {
  //       prims.recv(thisOutput+offset, nelem);
  //     } else {
  //       prims.recvCopySend(thisOutput+offset, nelem);
  //     }
  //   }
  // }
}

template<int UNUSED, class FUNC, typename T>
__device__ void ncclAllReduceComputationRingLLKernel(struct CollectiveArgs* args) {
  const int tid = threadIdx.x;
  const int bid = args->bid;
  const int nthreads = args->nThreads;
  struct ncclDevComm* comm = args->comm;
  struct ncclChannel* channel = comm->channels+blockIdx.x;
  struct ncclRing* ring = &channel->ring;

  ncclLLPrimitivesComputation<T, FUNC, 1, 1> LLprims(tid, nthreads, &ring->prev, &ring->next, channel, comm, args->opCount);

  const ssize_t size = args->N;
  //const int rank = comm->rank;
  const int nranks = comm->nRanks;
  ssize_t chunkSize = NCCL_LL_SLICE_LINES * sizeof(uint64_t) / sizeof(T);
  const ssize_t minChunkSize = nthreads * (sizeof(uint64_t)) / sizeof(T);

  const ssize_t loopSize = args->nChannels*nranks*chunkSize;

  // Compute pointers
  // const T * __restrict__ thisInput = (const T*)args->ThisInput;
  // T * __restrict__ thisOutput = (T*)args->ThisOutput;
  /*RINGLL: {INSERT ARGS}*/
  /*RINGLL: {INSERT SHARED MEMORY FOR REDUCTION}*/
  for (ssize_t gridOffset = 0; gridOffset < size; gridOffset += loopSize) {
    chunkSize = min(DIVUP(size-gridOffset, args->nChannels*nranks*minChunkSize)*minChunkSize, chunkSize);

    /////////////// begin AllReduce steps ///////////////
    ssize_t offset;
    int nelem;
    int chunk;

    // step 0: push data to next GPU
    chunk = ring->devUserRanks[nranks-1];
    offset = gridOffset + (chunk*args->nChannels+bid) * chunkSize;
    nelem = min(chunkSize, size-offset);

    /*RINGLL: {INSERT SEND}*/
    //LLprims.send(thisInput+offset, nelem);

    // k-2 steps: reduce and copy to next GPU
    for (int j=2; j<nranks; ++j) {
      chunk = ring->devUserRanks[nranks-j];
      offset = gridOffset + (chunk*args->nChannels+bid) * chunkSize;
      nelem = min(chunkSize, size-offset);

      /*RINGLL: {INSERT RECV_REDUCE_SEND}*/
      //LLprims.recvReduceSend(thisInput+offset, nelem);
    }

    // step k-1: reduce this buffer and data, which will produce the final
    // result that we store in this data and push to the next GPU
    chunk = ring->devUserRanks[0];
    offset = gridOffset + (chunk*args->nChannels+bid) * chunkSize;
    nelem = min(chunkSize, size-offset);

    /*RINGLL: {INSERT RECV_REDUCE_COPY_SEND}*/
    //LLprims.recvReduceCopySend(thisInput+offset, thisOutput+offset, nelem);
/*RINGLL: REDUCTION {END FOR LOOP FOR}*/
    
/*RINGLL: REDUCTION {PER-GPU REDUCTION}*/

/*RINGLL: REDUCTION {TRANSFER}*/
    
  /*RINGLL: REDUCTION {BEGIN FOR LOOP FOR}*/
  /*RINGLL: REDUCTION {COMPUTATION}*/
    // k-2 steps: copy to next GPU
    for (int j=1; j<nranks-1; ++j) {
      chunk = ring->devUserRanks[nranks-j];
      offset = gridOffset + (chunk*args->nChannels+bid) * chunkSize;
      nelem = min(chunkSize, size-offset);
      /*RINGLL: {INSERT RECV_COPY_SEND}*/
      //LLprims.recvCopySend(thisOutput+offset, nelem);
    }

    // Make final copy from buffer to dest.
    chunk = ring->devUserRanks[1];
    offset = gridOffset + (chunk*args->nChannels+bid) * chunkSize;
    nelem = min(chunkSize, size-offset);

    // Here we need to copy from buffer to this output.
    /*RINGLL: {INSERT RECV}*/
    //LLprims.recv(thisOutput+offset, nelem);
  }
}

template<int UNUSED, class FUNC, typename T>
__device__ void ncclAllReduceComputationTreeLLKernel(struct CollectiveArgs* args) {
  const int tid = threadIdx.x;
  const int nthreads = args->nThreads;
  const int bid = args->bid;
  struct ncclDevComm* comm = args->comm;
  struct ncclChannel* channel = comm->channels+blockIdx.x;
  const ssize_t size = args->N;
  ssize_t chunkSize = NCCL_LL_SLICE_LINES * sizeof(uint64_t) / sizeof(T);
  const ssize_t minChunkSize = nthreads*sizeof(uint64_t) / sizeof(T);
  const ssize_t loopSize = args->nChannels*chunkSize;

  if (loopSize > size) {
    chunkSize = DIVUP(size, args->nChannels*minChunkSize)*minChunkSize;
  }

  // Compute pointers
  // const T * __restrict__ thisInput = (const T*)args->ThisInput;
  // T * __restrict__ thisOutput = (T*)args->ThisOutput;
  /*TREELL: {INSERT ARGS}*/
  /*TREELL: {REDUCTION SHMEM}*/
  
  do {
    struct ncclTree* tree = &channel->treeUp;
    // Reduce : max number of recv is 3, max number of send is 1 (binary tree + local)
    ncclLLPrimitivesComputation<T, FUNC, NCCL_MAX_TREE_ARITY, 1> LLprims(tid, nthreads, tree->down, &tree->up, channel, comm, args->opCount);
    for (ssize_t gridOffset = 0; gridOffset < size; gridOffset += loopSize) {
      // Up
      ssize_t offset = gridOffset + bid*chunkSize;
      int nelem = min(chunkSize, size-offset);
      if (tree->up == -1) {
        /*TREELL: {INSERT recvReduceCopy2}*/
        //LLprims.recvReduceCopy2(thisInput+offset, thisOutput+offset, nelem);
      } else if (tree->down[0] == -1) {
        /*TREELL: {INSERT send}*/
        //LLprims.send(thisInput+offset, nelem);
      } else {
        /*TREELL: {INSERT recvReduceSend}*/
        //LLprims.recvReduceSend(thisInput+offset, nelem);
      }
    }

    if (tree->up == -1) {
      /*TREELL: REDUCTION {REDUCTION COMPUTATION}*/

      /*TREELL: REDUCTION {GLOBAL MEM REDUCTION}*/
      /*TREELL: REDUCTION {COMPUTATION}*/
    }
  } while(0);

  do {
    struct ncclTree* tree = &channel->treeDn;
    // Broadcast : max number of recv is 1, max number of send is 3 (binary tree + local)
    ncclLLPrimitivesComputation<T, FUNC, 1, NCCL_MAX_TREE_ARITY> LLprims(tid, nthreads, &tree->up, tree->down, channel, comm, args->opCount);
    for (ssize_t gridOffset = 0; gridOffset < size; gridOffset += loopSize) {
      // Down
      ssize_t offset = gridOffset + bid*chunkSize;
      int nelem = min(chunkSize, size-offset);
      if (tree->up == -1) {
        /*TREELL: {INSERT send output}*/
        //LLprims.send(thisOutput+offset, nelem);
      } else if (tree->down[0] == -1) {
        /*TREELL: {INSERT recv output}*/
        //LLprims.recv(thisOutput+offset, nelem);
      } else {
        /*TREELL: {INSERT recvCopySend output}*/
        //LLprims.recvCopySend(thisOutput+offset, nelem);
      }
    }
  } while(0);
}

template<int UNUSED, class FUNC, typename T>
__device__ void ncclAllReduceComputationCollNetLLKernel(struct CollectiveArgs* args) {
  assert(false);
  // const int tid = threadIdx.x;
  // const int nthreads = args->nThreads;
  // const int bid = args->bid;
  // struct ncclDevComm* comm = args->comm;
  // struct ncclChannel* channel = comm->channels+blockIdx.x;
  // const ssize_t size = args->N;
  // ssize_t chunkSize = NCCL_LL_SLICE_LINES * sizeof(uint64_t) / sizeof(T);
  // const ssize_t minChunkSize = nthreads*sizeof(uint64_t) / sizeof(T);
  // const ssize_t loopSize = args->nChannels*chunkSize;

  // if (loopSize > size) {
  //   chunkSize = DIVUP(size, args->nChannels*minChunkSize)*minChunkSize;
  // }

  // // Compute pointers
  // const T * __restrict__ thisInput = (const T*)args->ThisInput;
  // T * __restrict__ thisOutput = (T*)args->ThisOutput;

  // if (blockIdx.x < args->nChannels) { // first half of the channels do reduce
  //   struct ncclTree* tree = &channel->collTreeUp;
  //   ncclLLPrimitivesComputation<T, FUNC, 1, 1> LLprims(tid, nthreads, tree->down, &tree->up, channel, comm, args->opCount);
  //   for (ssize_t gridOffset = 0; gridOffset < size; gridOffset += loopSize) {
  //     // Up
  //     ssize_t offset = gridOffset + bid*chunkSize;
  //     int nelem = min(chunkSize, size-offset);
  //     if (tree->up == -1) {
  //       LLprims.recvReduceCopy(thisInput+offset, thisOutput+offset, nelem);
  //     } else if (tree->down[0] == -1) {
  //       LLprims.send(thisInput+offset, nelem);
  //     } else {
  //       LLprims.recvReduceSend(thisInput+offset, nelem);
  //     }
  //   }
  // }

  // if (blockIdx.x >= args->nChannels) { // second half of the channels do broadcast
  //   struct ncclTree* tree = &channel->collTreeDn;
  //   ncclLLPrimitivesComputation<T, FUNC, 1, 1> LLprims(tid, nthreads, &tree->up, tree->down, channel, comm, args->opCount);
  //   for (ssize_t gridOffset = 0; gridOffset < size; gridOffset += loopSize) {
  //     // Down
  //     ssize_t offset = gridOffset + bid*chunkSize;
  //     int nelem = min(chunkSize, size-offset);
  //     if (tree->up == -1) {
  //       LLprims.send(thisOutput+offset, nelem);
  //     } else if (tree->down[0] == -1) {
  //       LLprims.recv(thisOutput+offset, nelem);
  //     } else {
  //       LLprims.recvCopySend(thisOutput+offset, nelem);
  //     }
  //   }
  // }
}

#include "prims_ll128_computation.h"
template<int UNUSED, class FUNC, typename T>
__device__ void ncclAllReduceComputationRingLL128Kernel(struct CollectiveArgs* args) {
  const int tid = threadIdx.x;
  const int bid = args->bid;
  const int nthreads = args->nThreads;
  struct ncclDevComm* comm = args->comm;
  struct ncclChannel* channel = comm->channels+blockIdx.x;
  struct ncclRing* ring = &channel->ring;

  ncclLL128PrimitivesComputation<T, FUNC, 1, 1> LLprims(tid, nthreads, &ring->prev, &ring->next, channel, comm, args->opCount);

  const ssize_t size = args->N;
  //const int rank = comm->rank;
  const int nranks = comm->nRanks;
  ssize_t chunkSize = (NCCL_LL128_ELEMS_PER_THREAD*nthreads*NCCL_LL128_DATAELEMS*sizeof(uint64_t))/(NCCL_LL128_LINEELEMS*sizeof(T));
  // We should not need the final /2 but it makes performance much, much smoother. Might be a bug somewhere.
  const ssize_t minChunkSize = (NCCL_LL128_SHMEM_ELEMS_PER_THREAD*nthreads*NCCL_LL128_DATAELEMS*sizeof(uint64_t))/(NCCL_LL128_LINEELEMS*sizeof(T))/2;

  const ssize_t loopSize = args->nChannels*nranks*chunkSize;

  // Compute pointers
  /*RINGLL128: {INSERT ARGS}*/

  for (ssize_t gridOffset = 0; gridOffset < size; gridOffset += loopSize) {
    chunkSize = min(DIVUP(size-gridOffset, args->nChannels*nranks*minChunkSize)*minChunkSize, chunkSize);

    /////////////// begin AllReduce steps ///////////////
    ssize_t offset;
    int nelem;
    int chunk;

    // step 0: push data to next GPU
    chunk = ring->devUserRanks[nranks-1];
    offset = gridOffset + (chunk*args->nChannels+bid) * chunkSize;
    nelem = min(chunkSize, size-offset);
    /*RINGLL128: {INSERT SEND}*/
    //LLprims.send(thisInput+offset, nelem);

    // k-2 steps: reduce and copy to next GPU
    for (int j=2; j<nranks; ++j) {
      chunk = ring->devUserRanks[nranks-j];
      offset = gridOffset + (chunk*args->nChannels+bid) * chunkSize;
      nelem = min(chunkSize, size-offset);
      /*RINGLL128: {INSERT RECV_REDUCE_SEND}*/
      //LLprims.recvReduceSend(thisInput+offset, nelem);
    }

    // step k-1: reduce this buffer and data, which will produce the final
    // result that we store in this data and push to the next GPU
    chunk = ring->devUserRanks[0];
    offset = gridOffset + (chunk*args->nChannels+bid) * chunkSize;
    nelem = min(chunkSize, size-offset);

    /*RINGLL128: {INSERT RECV_REDUCE_COPY_SEND}*/
    //LLprims.recvReduceCopySend(thisInput+offset, thisOutput+offset, nelem);

    // k-2 steps: copy to next GPU
    for (int j=1; j<nranks-1; ++j) {
      chunk = ring->devUserRanks[nranks-j];
      offset = gridOffset + (chunk*args->nChannels+bid) * chunkSize;
      nelem = min(chunkSize, size-offset);
      /*RINGLL128: {INSERT RECV_COPY_SEND}*/
      //LLprims.recvCopySend(thisOutput+offset, nelem);
    }

    // Make final copy from buffer to dest.
    chunk = ring->devUserRanks[1];
    offset = gridOffset + (chunk*args->nChannels+bid) * chunkSize;
    nelem = min(chunkSize, size-offset);

    // Here we need to copy from buffer to this output.
    /*RINGLL128: {INSERT RECV}*/
    //LLprims.recv(thisOutput+offset, nelem);
  }
}

template<int UNUSED, class FUNC, typename T>
__device__ void ncclAllReduceComputationTreeLL128Kernel(struct CollectiveArgs* args) {
  const int tid = threadIdx.x;
  const int nthreads = args->nThreads;
  const int bid = args->bid;
  struct ncclDevComm* comm = args->comm;
  struct ncclChannel* channel = comm->channels+blockIdx.x;
  struct ncclTree* treeUp = &channel->treeUp;
  struct ncclTree* treeDn = &channel->treeDn;
  const ssize_t size = args->N;
  ssize_t chunkSize = args->lastChunkSize;
  const ssize_t minChunkSize = (NCCL_LL128_SHMEM_ELEMS_PER_THREAD*nthreads*NCCL_LL128_DATAELEMS*sizeof(uint64_t))/(NCCL_LL128_LINEELEMS*sizeof(T))/8;
  const ssize_t loopSize = args->nChannels*chunkSize;
  int nthreadsSplit = NCCL_LL128_SPLIT(nthreads);

  if (loopSize > size) {
    chunkSize = DIVUP(size, args->nChannels*minChunkSize)*minChunkSize;
  }

  // Compute pointers
  /*RINGLL128: {INSERT ARGS}*/
  if (treeUp->up == -1) {
    // ReduceAndBroadcast : max number of recv is 3, max number of send is 3
    ncclLL128PrimitivesComputation<T, FUNC, NCCL_MAX_TREE_ARITY, NCCL_MAX_TREE_ARITY> LLprims(tid, nthreads, treeUp->down, treeDn->down, channel, comm, args->opCount);
    for (ssize_t gridOffset = 0; gridOffset < size; gridOffset += loopSize) {
      ssize_t offset = gridOffset + bid*chunkSize;
      int nelem = min(chunkSize, size-offset);
      /*RINGLL128: {INSERT RECV_REDUCE_COPY_SEND}*/
      //LLprims.recvReduceCopySend(thisInput+offset, thisOutput+offset, nelem);
    }
  } else {
    if (tid < nthreadsSplit) {
      // Reduce : max number of recv is 3, max number of send is 1 (binary tree + local)
      ncclLL128PrimitivesComputation<T, FUNC, NCCL_MAX_TREE_ARITY, 1> LLprims(tid, nthreadsSplit, treeUp->down, &treeUp->up, channel, comm, args->opCount);
      for (ssize_t gridOffset = 0; gridOffset < size; gridOffset += loopSize) {
        // Up
        ssize_t offset = gridOffset + bid*chunkSize;
        int nelem = min(chunkSize, size-offset);
        if (treeUp->down[0] == -1) {
          /*RINGLL128: {INSERT SEND}*/
          // LLprims.send(thisInput+offset, nelem);
        } else {
          /*RINGLL128: {INSERT RECV_REDUCE_SEND}*/
          // LLprims.recvReduceSend(thisInput+offset, nelem);
        }
      }
    } else {
      // Broadcast : max number of recv is 1, max number of send is 3 (binary tree + local)
      ncclLL128PrimitivesComputation<T, FUNC, 1, NCCL_MAX_TREE_ARITY> LLprims(tid-nthreadsSplit, nthreads-nthreadsSplit, &treeDn->up, treeDn->down, channel, comm, args->opCount);
      for (ssize_t gridOffset = 0; gridOffset < size; gridOffset += loopSize) {
        // Down
        ssize_t offset = gridOffset + bid*chunkSize;
        int nelem = min(chunkSize, size-offset);
        if (treeDn->down[0] == -1) {
          /*RINGLL128: {INSERT RECV}*/
          // LLprims.recv(thisOutput+offset, nelem);
        } else {
          /*RINGLL128: {INSERT RECV_COPY_SEND}*/
          // LLprims.recvCopySend(thisOutput+offset, nelem);
        }
      }
    }
  }
}

template<int UNUSED, class FUNC, typename T>
__device__ void ncclAllReduceComputationCollNetLL128Kernel(struct CollectiveArgs* args) {assert(false); }
